calculate_average_and_check() {
	if [[ $skip_worker_check -eq 0 ]]; then
		local file="$1"
		echo "$file"
		avg=$(sed -e 's#.*,##' "$file" | tr '\n' ' ' | awk '{sum=0; for(i=1; i<=NF; i++) sum+=$i; print sum/NF}')
		echo "Average: $avg"
		failed=0
		NAME="Testing worker usage for $file: Below 80%? Got $avg%"

		if (( $(echo "$avg < 80" | bc -l) )); then
			errmsg="Error: average worker usage was less than 80% (actual: $avg%)"
			red_text "$errmsg\n"
			errors+=($(echo "$errmsg" | base64))
			failed=1
		fi


		LOG_TIMES+=("$failed,$NAME,$failed,0,0,$failed_true_false")
	fi
}


if [[ -n $RUN_WITH_COVERAGE ]]; then
	if command -v coverage 2>/dev/null >/dev/null; then
		coverage combine -i 2>/dev/null >/dev/null || true
		coverage xml -i 2>/dev/null >/dev/null || true
		coverage json -i 2>/dev/null >/dev/null || true
		coverage html -i 2>/dev/null >/dev/null || true

		coverage report -i || true

		if [[ -n $GITHUB_STEP_SUMMARY ]]; then
			echo "$(coverage report --format=markdown || true)" >> "$GITHUB_STEP_SUMMARY"
		fi

		if [[ -z $CI ]] && [[ -n $DISPLAY ]] && command -v firefox 2>/dev/null >/dev/null; then
			if [[ -e htmlcov/index.html ]]; then
				firefox htmlcov/index.html || true
			else
				red_text "htmlcov/index.html not found\n"
			fi
		fi
	else
		red_text "--run_with_coverage was defined, but coverage could not be found\n"
	fi
fi

unset_debug

IFS=',' read -r -a headers <<< "${LOG_TIMES[0]}"

declare -A max_lengths
for header in "${headers[@]}"; do
	max_lengths["$header"]=0
done

for entry in "${LOG_TIMES[@]}"; do                     
	IFS=',' read -r -a fields <<< "$entry"                   
	for i in "${!fields[@]}"; do    
		header="${headers[$i]}"
		if [[ -z "${headers[$i]}" ]]; then
			red_text "Error: No header for index $i found"
		else
			max_lengths["$header"]=${max_lengths["$header"]:-0}
			[[ ${#fields[$i]} -gt ${max_lengths["$header"]} ]] && max_lengths["$header"]=${#fields[$i]}
		fi
	done          
done

print_table() {
	# Define the headers and initialize the lengths for columns
	headers=("Failed" "Name" "TestRunTime" "ExitCode" "WantedExitCodes" "Success")
	max_lengths=()
	for header in "${headers[@]}"; do
		max_lengths[$header]=${#header}
	done

	# Process the table rows to determine maximum column widths
	for entry in "${LOG_TIMES[@]}"; do
		IFS=',' read -r -a fields <<< "$entry"
		for i in "${!fields[@]}"; do
			if [[ ${#fields[$i]} -gt ${max_lengths[${headers[$i]}]} ]]; then
				max_lengths[${headers[$i]}]=${#fields[$i]}
			fi
		done
	done

	# Create the header and separator lines
	header_line=""
	separator_line=""
	for header in "${headers[@]}"; do
		header_line+="| ${header}$(printf '%*s' $((max_lengths[$header] - ${#header} + 1)))"
		separator_line+="|$(for i in $(seq $((max_lengths[$header] + 1))); do printf '-'; done)-"
	done

	header_line+="|"

	border_line="+${separator_line:1}+"
	separator_line="+${separator_line:1}+"

	separator_line_cut_last=$(echo "$separator_line" | sed -e 's#.$##')
	end_line="+${separator_line_cut_last:1}+"
	end_line=$(echo "$end_line" | sed -e 's#|#+#g')

	border_line=$(echo "$border_line" | sed -e 's#|#+#g')
	separator_line=$(echo "$separator_line" | sed -e 's#|#+#g')

	# Print the table
	printf "%s\n" "$border_line"
	printf "%s\n" "$header_line"
	printf "%s\n" "$separator_line"

	i=0
	for entry in "${LOG_TIMES[@]}"; do
		if [[ $i -gt 0 ]]; then
			IFS=',' read -r -a fields <<< "$entry"
			line=""
			for j in "${!fields[@]}"; do
				# Check for failure and apply color if necessary
				if [[ $j -eq 0 && ${fields[$j]} -eq 1 ]]; then
					printf "\033[0;31m"  # Set red color
				fi

		# Append the field value to the line
		line+="| ${fields[$j]}$(printf '%*s' $((max_lengths[${headers[$j]}] + 1 - ${#fields[$j]})))"
	done

	line+="|"
	printf "%s\n\033[0m" "$line"  # Reset color
		fi
		i=$(($i+1))
	done

	printf "%s\n" "$end_line"
}

print_table_markdown() {
	headers=("Failed" "Name" "TestRunTime" "ExitCode" "WantedExitCodes" "Success")

	header_line="| "
	separator_line="|"
	for header in "${headers[@]}"; do
		header_line+="$header | "
		separator_line+="--- | "
	done

	printf "%s\n" "$header_line"
	printf "%s\n" "$separator_line"

	for entry in "${LOG_TIMES[@]}"; do
		IFS=',' read -r -a fields <<< "$entry"
		line="| "
		for field in "${fields[@]}"; do
			line+="$field | "
		done
		printf "%s\n" "$line"
	done
}

