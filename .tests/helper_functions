#!/bin/bash

function set_debug {
	trap 'echo -e "${CYAN}$(date +"%Y-%m-%d %H:%M:%S")${NC} ${MAGENTA}| Line: $LINENO ${NC}${YELLOW}-> ${NC}${BLUE}[DEBUG]${NC} ${GREEN}$BASH_COMMAND${NC}"' DEBUG
}

function extract_results() {
	local file="$1"
	if [[ ! -f "$file" ]]; then
		echo "File not found!"
		return 1
	fi

	awk -F, 'NR==1 {for (i=1; i<=NF; i++) if ($i == "result") col=i} NR>1 {print $col}' "$file"
}

function unset_debug {
	trap - DEBUG
}

calculate_average_and_check() {
	if [[ $skip_worker_check -eq 0 ]]; then
		local file="$1"
		echo "$file"
		avg=$(sed -e 's#.*,##' "$file" | tr '\n' ' ' | awk '{sum=0; for(i=1; i<=NF; i++) sum+=$i; print sum/NF}')
		echo "Average: $avg"
		failed=0
		NAME="Testing worker usage for $file: Below 80%? Got $avg%"

		if (( $(echo "$avg < 80" | bc -l) )); then
			errmsg="Error: average worker usage was less than 80% (actual: $avg%)"
			red_text "$errmsg\n"
			errors+=($(echo "$errmsg" | base64))
			failed=1
		fi


		LOG_TIMES+=("$failed,$NAME,$failed,0,0,$failed_true_false")
	fi
}

print_table() {
	# Define the headers and initialize the lengths for columns
	headers=("Failed" "Name" "TestRunTime" "ExitCode" "WantedExitCodes" "Success")
	max_lengths=()
	for header in "${headers[@]}"; do
		max_lengths[$header]=${#header}
	done

	# Process the table rows to determine maximum column widths
	for entry in "${LOG_TIMES[@]}"; do
		IFS=',' read -r -a fields <<< "$entry"
		for i in "${!fields[@]}"; do
			if [[ ${#fields[$i]} -gt ${max_lengths[${headers[$i]}]} ]]; then
				max_lengths[${headers[$i]}]=${#fields[$i]}
			fi
		done
	done

	# Create the header and separator lines
	header_line=""
	separator_line=""
	for header in "${headers[@]}"; do
		header_line+="| ${header}$(printf '%*s' $((max_lengths[$header] - ${#header} + 1)))"
		separator_line+="|$(for i in $(seq $((max_lengths[$header] + 1))); do printf '-'; done)-"
	done

	header_line+="|"

	border_line="+${separator_line:1}+"
	separator_line="+${separator_line:1}+"

	separator_line_cut_last=$(echo "$separator_line" | sed -e 's#.$##')
	end_line="+${separator_line_cut_last:1}+"
	end_line=$(echo "$end_line" | sed -e 's#|#+#g')

	border_line=$(echo "$border_line" | sed -e 's#|#+#g')
	separator_line=$(echo "$separator_line" | sed -e 's#|#+#g')

	# Print the table
	printf "%s\n" "$border_line"
	printf "%s\n" "$header_line"
	printf "%s\n" "$separator_line"

	i=0
	for entry in "${LOG_TIMES[@]}"; do
		if [[ $i -gt 0 ]]; then
			IFS=',' read -r -a fields <<< "$entry"
			line=""
			for j in "${!fields[@]}"; do
				# Check for failure and apply color if necessary
				if [[ $j -eq 0 && ${fields[$j]} -eq 1 ]]; then
					printf "\033[0;31m"  # Set red color
				fi

		# Append the field value to the line
		line+="| ${fields[$j]}$(printf '%*s' $((max_lengths[${headers[$j]}] + 1 - ${#fields[$j]})))"
	done

	line+="|"
	printf "%s\n\033[0m" "$line"  # Reset color
		fi
		i=$(($i+1))
	done

	printf "%s\n" "$end_line"
}

print_table_markdown() {
	headers=("Failed" "Name" "TestRunTime" "ExitCode" "WantedExitCodes" "Success")

	header_line="| "
	separator_line="|"
	for header in "${headers[@]}"; do
		header_line+="$header | "
		separator_line+="--- | "
	done

	printf "%s\n" "$header_line"
	printf "%s\n" "$separator_line"

	for entry in "${LOG_TIMES[@]}"; do
		IFS=',' read -r -a fields <<< "$entry"
		line="| "
		for field in "${fields[@]}"; do
			line+="$field | "
		done
		printf "%s\n" "$line"
	done
}

unshift() {
	local -n ary=$1
	local element=$2
	ary=("$element" "${ary[@]}")
}

function displaytime {
	local T=$1
		local D=$((T/60/60/24))
		local H=$((T/60/60%24))
		local M=$((T/60%60))
		local S=$((T%60))
		(( $D > 0 )) && printf '%d days ' $D
		(( $H > 0 )) && printf '%d hours ' $H
		(( $M > 0 )) && printf '%d minutes ' $M
		(( $D > 0 || $H > 0 || $M > 0 )) && printf 'and '
		printf '%d seconds\n' $S
}

function join_by {
	local d=${1-} f=${2-}
	if shift 2; then
		printf %s "$f" "${@/#/$d}"
	fi
}

function calltracer () {
	if [[ $EXPECTED_TO_FAIL -ne "1" ]]; then
		yellow_text "Git status hash:"
		git rev-parse HEAD
		red_text 'Error occurred in file/line:\n'
		caller
	fi
}

function _test {
	NAME=$1
	COMMAND=$2
	WANTED_EXIT_CODE=$3
	ALTERNATIVE_OK_EXIT_CODE=$4

	TEST_CASES+=("_test_internal \"$NAME\" \"$COMMAND\" $WANTED_EXIT_CODE $ALTERNATIVE_OK_EXIT_CODE")
}

function get_cpu_usage_percent {
        LANG=C top -bn1 | grep "Cpu(s)" | awk -F'id,' -v prefix="" '{split($1, vs, ","); v=vs[length(vs)]; sub("%","",v); print 100-v}'
}

function get_memory_usage_mb {
	free -m | awk 'NR==2 {print $3}'
}

function run_tests {
        local total=${#TEST_CASES[@]}
        local count=0

        for test_case in "${TEST_CASES[@]}"; do
                count=$((count + 1))
                local percent=$((count * 100 / total))
                local start_time=$(date +%s)

                if [[ $exit_on_first_error -eq 1 ]] && [[ ${#errors[@]} -gt 0 ]]; then
                        true
                else
                        _running_string="[$count/$total] (${percent}%) Running: $test_case"
                        _running_string=$(echo "$_running_string" | sed -e 's#[[:space:]]*$##')
                        _green_text_bold_underline "$_running_string"
                fi

                eval "$test_case"

                local end_time=$(date +%s)
                local duration=$((end_time - start_time))

                if [[ $duration -gt 10 ]]; then
                        RUN_TIMES+=("$duration")
                fi

                if ((${#RUN_TIMES[@]} > 1)); then
                        local sorted_times=($(printf "%s\n" "${RUN_TIMES[@]}" | sort -n))
                        local mid_index=$((${#sorted_times[@]} / 2))
                        local median=${sorted_times[$mid_index]}
                        local remaining=$((median * (total - count)))

                        local readable_time
                        if ((remaining >= 3600)); then
                                readable_time="$(($remaining / 3600))h $(($remaining % 3600 / 60))m"
                        elif ((remaining >= 60)); then
                                readable_time="$(($remaining / 60))m $(($remaining % 60))s"
                        else
                                readable_time="${remaining}s"
                        fi

                        if [[ $remaining -gt 0 ]]; then
                                if [[ $exit_on_first_error -eq 1 ]] && [[ ${#errors[@]} -gt 0 ]]; then
                                        true
                                else
                                        _green_text_bold_underline "-> Estimated time remaining: $readable_time"
                                fi
                        fi
                fi

                if [[ -d None ]]; then
                        red_text "None exists. Will fail."
                        exit 1
                fi

                if [[ -d runs/None ]]; then
                        red_text "runs/None exists. Will fail."
                        exit 1
                fi
        done
}

# _test "NAME" "COMMAND" "WANTED_EXIT_CODE" "ERRORMSG"
function _test_internal {
	if [[ "$skip_first_n_tests" != "" ]]; then
		if [[ $test_counter -lt $skip_first_n_tests ]]; then
			yellow_text "Skipping test $test_counter, will start at $skip_first_n_tests"

			test_counter=$(($test_counter+1))

			return 0
		fi
	fi

	if [[ -d None ]]; then
		echo "None folder exists before (!!!) test $name -> $command"
		exit 1
	fi

	NAME=$1
	COMMAND=$2
	WANTED_EXIT_CODE=$3
	ALTERNATIVE_OK_EXIT_CODE=$4

	if echo "$NAME" | grep -q "," 2>/dev/null >/dev/null; then
		red_text "The name '$NAME' contains a comma, which, later on, will confuse the table generation tool. Please remove the comma from the name.\n"
		exit 255
	fi

	if [[ $exit_on_first_error -eq 1 ]] && [[ ${#errors[@]} -gt 0 ]]; then
		return
	fi

	#yellow_text "$NAME..."

	if [[ -z $NAME ]]; then
		echo "_test: first parameter (name) not specified"
		exit 19
	fi

	if [[ -z $COMMAND ]]; then
		echo "_test: second parameter (command) not specified"
		exit 19
	fi

	if [[ -z $WANTED_EXIT_CODE ]]; then
		echo "_test: third parameter (wanted exit code) not specified"
		exit 19
	fi

	if [[ "$WANTED_EXIT_CODE" == "$ALTERNATIVE_OK_EXIT_CODE" ]]; then
		echo "_test: WANTED_EXIT_CODE = ALTERNATIVE_OK_EXIT_CODE. If specified, must be different."
		exit 19
	fi

	set +e

	START_TIME=$(date +%s)


	declare -A ACTIONS=(
		["omniopt "]='set_skip_search'
		["start_simple_optimization_run"]='set_skip_search'
		["phases_overview"]='_skip_job'
		["external_generator"]='_skip_job'
		["adding_jobs_to_new_job"]='_skip_job'
	)

	set_skip_search() {
		export SKIP_SEARCH=1
		export SKIP_SEARCH_EXIT_CODE="$WANTED_EXIT_CODE"
		export COMMAND="$COMMAND --skip_search"
		yellow_text "Setting SKIP_SEARCH=1 and SKIP_SEARCH_EXIT_CODE=$WANTED_EXIT_CODE, added --skip_search to command"
	}

	skip_job=0

	_skip_job() {
		yellow_text "Totally skipping this test"
		skip_job=1
	}

	process_command() {
		local found=0
		for pattern in "${!ACTIONS[@]}"; do
			if echo "$COMMAND" | grep -q "$pattern"; then
				"${ACTIONS[$pattern]}"
				found=1
				break
			fi
		done
	}

	if [[ $skip_search -eq 1 ]]; then
		process_command
	fi

	if [[ $skip_job -eq 1 ]]; then
		exit_code=$wanted_exit_code
	else
		eval "$COMMAND"
		exit_code=$?
	fi

	END_TIME=$(date +%s)
	TEST_RUN_TIME=$(($END_TIME - $START_TIME))
	
	failed=0

	wanted_exit_codes=$WANTED_EXIT_CODE
	if [[ -n $ALTERNATIVE_OK_EXIT_CODE ]]; then
		wanted_exit_codes="$WANTED_EXIT_CODE/$ALTERNATIVE_OK_EXIT_CODE"
	fi

	set -e

	failed_true_false="✓"

	if [[ -z $ALTERNATIVE_OK_EXIT_CODE ]]; then
		if [[ "$exit_code" -eq "$WANTED_EXIT_CODE" ]]; then
			ERRORMSG=""
		else
			ERRORMSG="$NAME exited with $exit_code (wanted $WANTED_EXIT_CODE). Command: $COMMAND"
		fi

		if [[ $(echo $ERRORMSG | wc -c) -gt 2 ]]; then
			red_text "$ERRORMSG\n"
			errors+=($(echo "$ERRORMSG" | base64))
			failed_true_false="❌"
			failed=1
		fi
	else
		if [[ "$ALTERNATIVE_OK_EXIT_CODE" -eq "$exit_code" || "$exit_code" -eq "$WANTED_EXIT_CODE" ]]; then
			ERRORMSG=""
		else
			ERRORMSG="$NAME exited with $exit_code (wanted $WANTED_EXIT_CODE or $ALTERNATIVE_OK_EXIT_CODE). Command: $COMMAND"
		fi

		if [[ $(echo $ERRORMSG | wc -c) -gt 2 ]]; then
			red_text "$ERRORMSG\n"
			errors+=($(echo "$ERRORMSG" | base64))
			failed_true_false="❌"
			failed=1
		fi
	fi

	LOG_TIMES+=("$failed,$NAME,$TEST_RUN_TIME,$exit_code,$wanted_exit_codes,$failed_true_false")

	echo "Test took $(displaytime $TEST_RUN_TIME)"

	#if [[ -d None ]]; then
	#	echo "None found. Exiting."
	#	exit 0
	#fi
	
	if [[ -d None ]]; then
		echo "None folder exists after test $name -> $command"
		exit 1
	fi
}

function delete_test {
	tn=$1
	if [[ -d "runs/$tn" ]]; then
		yellow_text "Deleting old runs/$tn..."
		if [[ -d runs/$tn ]]; then
			rm -rf "runs/$tn"
		fi
	fi
}

function _test_nr_jobs {
	_testname=$1
	JOBNR=$2
	NRRAND=$3
	NRNONRAND=$4
	NRMANUAL=$5

	if [[ $skip_test_job_nr -eq 0 ]]; then
		_test "Testing if there are the right number of jobs in runs/$_testname/$JOBNR/results.csv" "./.tools/phases_overview runs/$_testname/$JOBNR/ $NRRAND $NRNONRAND $NRMANUAL" 0
	fi
}

file_has_changed_since_last_tagged_version() {
	local patterns=("$@")

	local last_tag
	last_tag=$(git describe --tags --abbrev=0 2>/dev/null)

	echo "Got last tag: $last_tag"

	if [[ -z "$last_tag" ]]; then
		return 0
	fi

	for pattern in "${patterns[@]}"; do
		for file in "$pattern"; do
			if git diff --name-only "$last_tag" -- "$file" | grep -q .; then
				return 0
			fi
		done
	done

	return 1
}
