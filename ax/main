#!/bin/bash

set -e
set -o pipefail

function calltracer () {
        echo 'Last file/last line:'
        caller
}

trap 'calltracer' ERR

function echoerr() {
        echo "$@" 1>&2
}

function red_text {
        echoerr -e "\e[31m$1\e[0m"
}

minutes_to_hh_mm_ss() {
	local total_minutes="$1"
	local hours=$(( total_minutes / 60 ))
	local minutes=$(( total_minutes % 60 ))
	local seconds=$(( minutes * 60 ))

	printf "%02d:%02d:%02d\n" "$hours" "$minutes" "$seconds"
}

export mem_gb=
export gres=
export time=
export help=0

for i in $@; do
        case $i in
                --mem_gb=*)
                        mem_gb="${i#*=}"
                        re='^[+-]?[0-9]+$'
                        if ! [[ $mem_gb =~ $re ]] ; then
                                red_text "error: Not a INT: $i" >&2
				exit 100
                        fi
                        ;;
                --gres=*)
                        gres="${i#*=}"
                        ;;
                --help*)
			help=1
                        ;;
                --time=*)
                        time="${i#*=}"
                        ;;
                --debug)
                        set -x
                        ;;
        esac
done

if [[ $help -eq 0 ]] && command -v sbatch >/dev/null; then
	if [[ -z "$mem_gb" ]]; then
		red_text "Parameter --mem_gb cannot be empty";
		exit 101
	fi

	if [[ -z "$time" ]]; then
		red_text "Parameter --time cannot be empty";
		exit 102
	fi
fi

sent_usr_signal_to_script=0
python_pid=

JOB_START_TIME=$SLURM_JOB_START_TIME
JOB_END_TIME=$SLURM_JOB_END_TIME

run_before_end () {
	if command -v sbatch >/dev/null; then
		sleep_time=$((JOB_END_TIME - JOB_START_TIME - 30))
		# Überprüfen, ob die Zeitdifferenz positiv ist, um zu vermeiden, dass das Skript im negativen Bereich schläft
		if [ $sleep_time -gt 0 ]; then
			sleep $sleep_time

			if [[ $sent_usr_signal_to_script -eq 0 ]]; then
				sent_usr_signal_to_script=1
				kill -USR1 "$python_pid"
			else
				echo "Already sent user signal to python PID $python_pid. Not doing that again."
			fi
		else
			echo "It is recommended that you run this in a slurm job."
		fi
	fi
}

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

if [ -n "${SLURM_JOB_ID:-}" ] ; then
	if [[ -z $DEBUG_SLURM ]]; then
		SLURM_FILE_SCRIPT_DIR=$(scontrol show job "$SLURM_JOB_ID" | awk -F= '/Command=/{print $2}')
		SLURM_FILE_SCRIPT_DIR=$(dirname $SLURM_FILE_SCRIPT_DIR)

		if [[ -d $SLURM_FILE_SCRIPT_DIR ]]; then
			SCRIPT_DIR="$SLURM_FILE_SCRIPT_DIR"
		else
			echo "SLURM_FILE_SCRIPT_DIR $SLURM_FILE_SCRIPT_DIR not found, even though SLURM_JOB_ID exists ($SLURM_JOB_ID). Using SCRIPT_DIR=$SCRIPT_DIR"
		fi
	fi
fi

cd $SCRIPT_DIR

source .shellscript_functions

if [ -n "${SLURM_JOB_ID:-}" ] || ! command -v sbatch >/dev/null; then
	# To start all subjobs indenpedently from the main job, unset all SLURM variables
	for i in $(env | egrep "^SLURM" | sed -e 's#\s*=.*##' | grep -v SLURM_JOB_ID); do
		unset $i
	done

	IFS=$' '
	python3 .main.py $* &
	python_pid=$!

	run_before_end &

	wait "$python_pid"
else
	IFS=$' '

	formatted_time=$(minutes_to_hh_mm_ss $time)

	if [[ ! -z $gres ]]; then
		sbatch --time=$formatted_time --mem=${mem_gb}GB --gres=$gres $SCRIPT_DIR/main $*
	else
		sbatch --time=$formatted_time --mem=${mem_gb}GB $SCRIPT_DIR/main $*
	fi
fi
